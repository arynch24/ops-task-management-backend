// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  ADMIN
  MEMBER
}

enum TaskType {
  ADHOC
  RECURRING
}

enum ParameterType {
  NUMBER
  TEXT
  DATETIME
  DROPDOWN
  BOOLEAN
  COMMENT
}

enum ScheduleStatus {
  PENDING
  ASSIGNED
  SKIPPED
  CANCELLED
}

enum AssignmentStatus {
  PENDING
  COMPLETED
}

enum NotificationType {
  TASK_ASSIGNED
  TASK_REASSIGNED
  TASK_COMPLETED
  DAILY_DIGEST
}

// Models

model User {
  id        String   @id @default(uuid())
  email     String   @unique @db.VarChar(255)
  firstName String   @db.VarChar(100)
  lastName  String   @db.VarChar(100)
  role      Role     @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  createdCategories    Category[]            @relation("CategoryCreator")
  createdSubcategories Subcategory[]         @relation("SubcategoryCreator")
  createdTasks         Task[]                @relation("TaskCreator")
  assignedTasks        TaskAssignment[]      @relation("TaskAssignee")
  assignedByTasks      TaskAssignment[]      @relation("TaskAssigner")
  assignmentGroups     TaskAssignmentGroup[] @relation("AssignedUsers")
  notifications        Notification[]

  @@map("users")
}

model Category {
  id            String   @id @default(uuid())
  name          String   @db.VarChar(255)
  description   String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     String   @db.VarChar(255)
  createdByUser User     @relation("CategoryCreator", fields: [createdBy], references: [id])

  subcategories Subcategory[]
  tasks         Task[]

  @@map("categories")
}

model Subcategory {
  id            String   @id @default(uuid())
  name          String   @db.VarChar(255)
  description   String?  @db.Text
  categoryId    String   @db.VarChar(255)
  category      Category @relation(fields: [categoryId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     String   @db.VarChar(255)
  createdByUser User     @relation("SubcategoryCreator", fields: [createdBy], references: [id])

  tasks Task[]

  @@map("subcategories")
}

/// Represents a template for a task (either one-time or recurring)
model Task {
  id            String  @id @default(uuid())
  title         String  @db.VarChar(255)
  description   String? @db.Text
  categoryId    String? @db.VarChar(255)
  subcategoryId String? @db.VarChar(255)

  /// Required for recurring tasks (enforced in application layer)
  category            Category?     @relation(fields: [categoryId], references: [id])
  subcategory         Subcategory?  @relation(fields: [subcategoryId], references: [id])
  createdBy           String        @db.VarChar(255)
  createdByUser       User          @relation("TaskCreator", fields: [createdBy], references: [id])
  taskType            TaskType
  parameterType       ParameterType
  parameterLabel      String        @db.VarChar(255) // e.g., "Battery Voltage"
  parameterUnit       String?       @db.VarChar(50) // e.g., "Volts", "¬∞C", "psi"
  parameterIsRequired Boolean       @default(true)
  dropdownOptions     String[] // Only for DROPDOWN type, e.g., ["High", "Medium", "Low"]
  repetitionConfig    Json? // Rule-based config for recurring tasks
  /**
   * Example:
   * {
   * type: "interval",
   * days: 3,
   * atTime: "09:00",
   * }
   * OR
   * {
   * type: "weekly",
   * onDays: ["MON", "WED", "FRI"],
   * atTime: "10:30",
   * }
   * OR
   * {
   * type: "monthly",
   * onDate: 15,
   * atTime: "08:00"
   * }
   */

  lastGenerated DateTime? // When schedules were last generated (e.g., 6 months out)
  dueDate       DateTime? // Optional: for ADHOC tasks

  timezone  String?  @default("UTC") // Task execution timezone
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recurringSchedules  RecurringTaskSchedule[]
  taskAssignments     TaskAssignment[]
  TaskAssignmentGroup TaskAssignmentGroup?

  @@map("tasks")
}

model RecurringTaskSchedule {
  id            String           @id @default(uuid())
  taskId        String           @db.VarChar(255)
  task          Task             @relation(fields: [taskId], references: [id])
  scheduledDate DateTime
  status        ScheduleStatus   @default(PENDING)
  assignments   TaskAssignment[]
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([taskId, scheduledDate])
  @@index([scheduledDate, status])
  @@map("recurring_task_schedules")
}

model TaskAssignment {
  id             String                 @id @default(uuid())
  taskId         String                 @db.VarChar(255)
  task           Task                   @relation(fields: [taskId], references: [id])
  scheduleId     String?
  schedule       RecurringTaskSchedule? @relation(fields: [scheduleId], references: [id])
  assignedTo     String                 @db.VarChar(255)
  assignedToUser User                   @relation("TaskAssignee", fields: [assignedTo], references: [id])
  assignedBy     String                 @db.VarChar(255)
  assignedByUser User                   @relation("TaskAssigner", fields: [assignedBy], references: [id])
  status         AssignmentStatus       @default(PENDING)
  parameterValue String?                @db.Text // Store submitted value as string (parse based on type)
  comment        String?                @db.Text
  completedAt    DateTime?
  createdAt      DateTime               @default(now())
  updatedAt      DateTime               @updatedAt

  notifications Notification[]

  // üîê Prevent duplicate assignments
  @@unique([taskId, assignedTo, scheduleId]) // scheduleId can be null for ADHOC tasks
  @@index([assignedTo, status])
  @@index([taskId, scheduleId])
  @@map("task_assignments")
}

model TaskAssignmentGroup {
  id            String   @id @default(uuid())
  taskId        String   @unique
  task          Task     @relation(fields: [taskId], references: [id])
  assignedToIds User[]   @relation("AssignedUsers")
  assignedBy    String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("task_assignment_groups")
}

/// Notifications (email logs + read status)
model Notification {
  id               String           @id @default(uuid())
  userId           String           @db.VarChar(255)
  user             User             @relation(fields: [userId], references: [id])
  taskAssignmentId String?          @db.VarChar(255)
  taskAssignment   TaskAssignment?  @relation(fields: [taskAssignmentId], references: [id])
  type             NotificationType
  message          String           @db.Text
  isRead           Boolean          @default(false)
  emailSent        Boolean          @default(false)
  emailError       String? // If email failed
  createdAt        DateTime         @default(now())

  @@index([userId, isRead])
  @@index([type, createdAt])
  @@map("notifications")
}
